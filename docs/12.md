# 12. 테스트 주도 개발

## TDD의 주된 이익

- 코드를 깨끗하게 유지할 수 있게 치열하게 싸우지 않으면 시스템은 점점 퇴화한다.
- TDD에서는 코드가 변경되어 망가질 것이라는 두려움을 지울 수 있다.
- TDD를 잘 따른다면 구현하는 실질적인 모든 사례에 단위 테스트를 작성하게 된다.

## 단순하게 시작

- TDD는 세 부분의 사이클로 구성된다.
  - `실패하는 테스트 코드 작성`하기
  - `테스트 통과`하기
  - 이전 두 단계에서 추가되거나 변경된 `코드 개선`하기
- 첫 번째 단계는 `시스템에 추가하고자 하는 동작을 정의하는 테스트 코드를 작성`하는 것이다.
  - 실습으로 Profile 클래스를 다시 만든다. 프로파일이 비었을 때 어떤 일이 일어나는지 본다.

```java
public class ProfileTest {
   @Test
   public void matchesNothingWhenProfileEmpty() {
      new Profile();
   }
}
```

- Profile 클래스가 존재하지 않으므로 새롭게 만들어야 된다.
- 에러가 나지 않고 컴파일 되면 충분하다.

```java
package iloveyouboss;

public class Profile {
}
```

- 같은 방식으로 나머지 테스트도 작성한다.

```java
public class ProfileTest {
   @Test
   public void matchesNothingWhenProfileEmpty() {
      Profile profile = new Profile();
      Question question = new BooleanQuestion(1, "Relocation package?");
      Criterion criterion = 
         new Criterion(new Answer(question, Bool.TRUE), Weight.DontCare);
      
      boolean result = profile.matches(criterion);
      
      assertFalse(result);
   }
}
```

- matches() 메서드의 인자로 Criteria라는 컬렉션을 받지 않고 단일 Criterion을 받도록 변경했다.
  - 한 번에 한 개씩 매칭하는 것이 단순하고 나중에 복수에 매칭하는 기능을 추가할 수 있다.
- 항상 `테스트가 먼저 실패`해야 한다. 그래야 기대하는 동작이 아직 시스템에 존재하지 않는다는 것을 알 수 있다.
- 테스트가 실패하는데 `assertFalse()`로 false를 기대하고 있으므로 메서드는 true를 반환하고 있다는 사실을 알 수 있다.

```java
public boolean matches(Criterion criterion) {
    return true;
}
```

- 테스트 실패를 확인한 후 `테스트가 통과하기 가장 쉬운 방법`을 찾는다. 바로 `true를 false로 뒤집는 것`이다.

```java
public boolean matches(Criterion criterion) {
    return false;
}
```

- 테스트 코드와 프로덕션 코드를 봐도 문제될 것은 없다. 따라서 더 이상 작업할 필요가 없다.
- 하드 코딩된 false 반환이 이상해 보이지만 `TDD의 점진적인 사고 방식`을 따르는 것이 중요하다.
- TDD를 하면 작은 코드를 git에 커밋하는 것은 `필요할 때 백업이나 되돌리기 수월`하다.

---
[Home](../README.md)
