# 14. 프로젝트에서 테스트

## 빠른 도입

- 단위 테스트와 같은 실천법을 배우는 건 끊임없는 경계를 요구한다.
- 단위 테스트는 품질 통제의 일부가 된다.

## 팀과 같은 편 되기

- 개발자가 단위 테스트에 접근하는 방식은 개인별로 다르다.
  - TDD, 필요한 테스트에서만 단위 테스트, 다수 케이스를 단일 테스트에 몰아놓기, 느린 통합 테스트 등 각자 선호하는 스타일이 있다.
- 팀이 같은 편이 되는 것이 중요하다. 모든 것에 동의할 수 없더라도 동의하고 합의점을 늘려가는 방향으로 시작해야 한다.

### 단위 테스트 표준 만들기

- 단위 테스트에 관한 표준을 도출하고 싶을 때 다음 두 질문에 대답해본다.
  - 개발자는 어떤 것이 모든 사람의 시간을 많이 낭비하게 한다고 느끼는가?
  - 모두가 빠르게 동의할 수 있는 단순한 표준은 무엇인가?
- 토론의 씨앗을 뿌리고 회의를 빠르게 진행하여 팀에 대한 기대 사항을 적어보자.
- 거기서 멈추지 않고 필요할 때마다 표준을 살피고 수정해야 한다.
- `초창기에 표준화해야 하는 목록`은 다음과 같다.
  - 코드를 체크인하기 전에 어떤 테스트를 실행해야 할지 여부
  - 테스트 클래스와 메서드 명명 방식
  - hamcrest 혹은 전통적인 단언 사용 여부
  - AAA 사용 여부
  - 선호하는 목 도구 선택
  - 체크인 테스트를 실행할 때 콘솔에 출력을 허용할지 여부
  - 단위 테스트 스위트에서 느린 테스트를 분명하게 식별하고 막을 방법
  
### 리뷰로 표준 준수 높이기

- 표준을 준수하는 것은 쉽지 않다.
- 코드 리뷰를 통해 서로 준수할 수 있게 독려한다.
- 리뷰 세션을 통해 단위 테스트 작성자가 다른 팀원에게 피드백을 요청할 수 있다.
  - [페이건 검사(Fagan inspections)](https://en.wikipedia.org/wiki/Fagan_inspection) 같은 기법을 사용하여 리뷰 절차를 공식화할 수 있다.
- 또 다른 장치는 `풀 리퀘스트(pull request)`를 활용하는 것이다.
  - 메인 브랜치에 통합하려는 작업 내용에 대한 풀 리퀘스트를 제출할 수 있다.
  - 다른 팀원이 주석을 달고 결과적으로 메인 브랜치에 병합할지 결정한다.
- 일부 IDE는 코드 리뷰 플러그인을 제공한다.

### 페어 프로그래밍을 이용한 리뷰

- 두 프로그래머가 함께 앉아 소프트웨어를 개발하는 것이다.
- 사후 리뷰에는 몇 가지 도전 과제가 있다.
  - 대부분 리뷰어는 코드에 대해 익숙하지 않다.
  - 현실적으로 시간적 여유가 없다.
- 결과적으로 바라는 것보다 더 적은 결함을 찾게 된다. 교정된 결함도 일반적으로 표면 수준(suface-level)이다.
- 게다가 사후 리뷰는 심각한 문제를 고치는 데 너무 늦는다.
  - 코드가 만들어지고 배포될 준비를 한 후, 코드를 되돌리거나 재작업하는 것을 부담스러워 한다.
- 하지만 페어 프로그래밍은 두 번째 사람의 눈으로 처음부터 품질 좋은 코드를 만들 수 있다는 희망을 준다.

## 지속적 통합으로 수렴

- 환경에 따라 동작하지 않는 코드가 발생하기도 한다.
- 단위 테스트는 이런 문제를 해결해주진 않지만 일종의 표준이다.
- 코드를 수정하는 것이 집합적인 테스트를 망가뜨릴 수는 없다. 다른 표준(테스트)을 위반한 것이다.
- 단위 테스트를 팀 차원의 표준으로 바라보려면 공유 저장소가 필요하다.
  - 저장소에서 코드를 체크아웃하고 변경한 뒤 로컬에서 테스트하고 다시 공유 저장소로 통합한다.
- 옛 사고방식 중 최전선에 있는 건 공유된 코드를 야간에 빌드(nightly build)하는 것이다.
- 야간 빌드에 단위 테스트와 다른 자동화 테스트를 추가하면 가치가 극적으로 향상될 것이다.
- 올바른 방향이지만 야간 빌드는 옛스럽고 부적절하다.
  - 개발자들이 더 많은 코드를 추가하면 할수록 통합되었을 때 동작하지 않을 가능성이 높아진다.
  - 그리고 이는 시간이 많이 걸린다.
- 더 빠른 피드백을 받기 위해 `지속적인 통합(CI)`을 하는 것이 좋다.
- CI를 하려면 지속적 통합 서버라는 도구의 지원을 받아야 된다.
  - CI 서버는 소스 저장소를 모니터링한다.
  - 새로운 코드가 체크인되면 CI 서버는 저장소에서 코드를 가져와 빌드를 초기화한다.
  - 빌드에 문제가 있으면 통지한다.
- CI 서버는 개발자를 압박할 것이다. 습관적으로 스스로 단위 테스트를 돌려보고 체크인하게 된다.

## 코드 커버리지

- 코드 커버리지는 얼마나 많은 코드가 단위 테스트 되었는가를 표시한다.
- Emma, Cobertura가 대표적인 예다.
- 어떤 도구는 분기 커버리지(branch coverage)를 측정한다.
  - 각 조건문은 분기를 의미하고 분기의 참 조건과 거짓 조건을 테스트하면 100%다.

### 커버리지는 어느 정도여야 하는가?

- 표면적으로 높은 코드 커버리지가 좋고 낮은 커버리지는 나쁘다.
- 커버리지 개념은 속임수를 써야만 100%에 도달할 수 있는 제한이 내재되어 있다.
  - 인자 없는 생성자는 테스트 코드에서 직접 호출하지 않기 때문에 코드 커버리지에 포함되지 않는다.
  - 100%를 맞추기 위해서 클래스만 인스턴스화 하는 단위 테스트를 작성할 수도 있다.
- 대부분은 `70% 이하 커버리지는 불충분`하다고 한다.

### 100% 커버리지는 진짜 좋은가?

- 설계가 좋을수록 테스트 작성도 쉽다.
- 좋은 설계는 100% 가까운 커버리지에 도달할 수 있게 도와줄 것이다.
- TDD를 수행하는 개발자는 일반적으로 정의상 90%를 초과 달성한다.
- 커버리지 퍼센트 자체는 오도될 수 있다.

### 코드 커버리지의 가치

- 단위 테스트를 하다보면 테스트가 어느 코드를 커버하고 있는지 알고 싶을 것이다.
- 코드 커버리지를 측정하는 도구는 이를 가시적으로 보여준다.
- 테스트 작성으 완료했을 때 커버리지 도구를 실행해보자.
- 코드 커버리지 숫자 자체는 의미 없지만 추세는 중요하다.

---
[Home](../README.md)
