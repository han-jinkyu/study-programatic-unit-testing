# 11. 테스트 리팩토링

## 이해 검색

- iloveyouboss_test-1/test/util/SearchTest.java
- SearchTest 클래스의 testSearch 메서드는 이해하기 어렵다.
  - 테스트 이름인 testSearch는 제대로 된 정보를 제공하지 않는다.
  - 주석 또한 마찬가지다.
- 테스트를 이해하려면 테스트를 읽고 의미를 해석해야 한다.
- 좀 더 깔끔하고 표현력 좋은 테스트로 만들기 위해 악취를 풍기는 코드의 `테스트 냄새(test smell)`을 찾아야 한다.

## 테스트 냄새: 불필요한 테스트 코드

- testSearch 메서드는 어떤 예외도 던지지 않고 try/catch로 잡아서 System.out으로 출력한다.
- 오히려 테스트 메서드가 예외를 던지게 두는 것이 낫다. JUnit은 `테스트가 던지는 예외를 모두 잡아준다`.

```java
@Test
public void testSearch() throws IOException {
    String pageContent = "There are certain queer times and occasions " +
    // ...
    stream.close();
}
```

- not-null 단언은 어떤 값이 null이 아님을 검증한다.
- 어떤 변수가 null인지 검사하는 것은 프로덕션 코드에선 좋지만 테스트에서는 군더더기다.
- null이라면 예외를 던지기 마련이고 이는 JUnit이 잡아서 오류로 처리하기 때문이다.

```java
List<Match> matches = search.getMatches();
// assertThat(matches, is(notNullValue()));
assertTrue(matches.size() >= 1);
```

## 테스트 냄새: 추상화 누락

- 잘 구성된 테스트는 시스템과의 상호 작용을 다음 3가지 관점에서 보여준다.
  - 데이터 준비하기 (arrange)
  - 시스템과 동작하기 (act)
  - 결과 단언하기 (assert)
- 테스트를 진행할 때는 각 단계를 위한 자세한 코드가 필요하지만 `세부 사항을 추상화`하여 이해하기 쉽게 한다.

```java
List<Match> matches = search.getMatches();
assertTrue(matches.size() >= 1);
Match match = matches.get(0);
assertThat(match.searchString, equalTo("practical joke"));
assertThat(match.surroundingContext, equalTo(
      "or a vast practical joke, though t"));
```

- iloveyouboss_test-2/test/util/SearchTest.java
- 뒤죽박죽인 테스트는 search.getMatches()이 반환하는 매칭 목록에 대한 단언문 5줄을 포함한다.

```java
// ...
import static util.ContainsMatches.*;

public class SearchTest {
   @Test
   public void testSearch() throws IOException {
      String pageContent = "There are certain queer times and occasions " +
      // ...
      search.execute();
      assertFalse(search.errored());
      assertThat(search.getMatches(), containsMatches(new Match[] { 
         new Match("1", "practical joke", 
                   "or a vast practical joke, though t") }));
      stream.close();
      // ...
   }
}
```

- ContainsMatches 사용자 정의 매처는 matches 변수가 Match 객체를 포함하고 있을 떄 특정 검색 문자열과 주변 맥락을 포함하는지 단언할 수 있게 해준다.
- iloveyouboss_test-3/test/util/ContainsMatches.java
  - 사용자 정의 매처가 오히려 많은 코드를 야기하지만 testSearch() 내 코드를 이해하기 위해 들여야 할 수고를 덜게 해주므로 가치가 있다.
- 단일 개념을 나타내는 코드가 2줄 이상이면 1줄로 줄일 수 있을지 고민해 보는 게 좋다.

```java
assertThat(search.getMatches().size(), equalTo(0));
```

```java
assertThat(search.getMatches().isEmpty());
```

- 위 코드는 마지막 단언은 결과 크기가 0인지 비교한다.
- 여기서 누락된 추상화는 `비어 있음(emptiness)`이라는 개념이다.
- 따라서 아래와 같은 코드로 바꾸는 것이 읽기 좋다.

## 테스트 냄새: 부적절한 정보

- 잘 추상화된 테스트는 코드를 이해하기 좋고 중요한 것이 뭔지 보여준다.
- 때로는 테스트에 영향을 주지 않지만 컴파일을 위한 인수를 넣기도 한다.

```java
Search search = new Search(stream, "practical joke", "1");
```
```java
assertThat(search.getMatches(), containsMatches(new Match[] { 
  new Match("1", "practical joke", 
            "or a vast practical joke, though t") }));
```

- 위 코드에서 문자열 "1"이 무슨 의미인지 알기 어렵다.
- "1"과 같은 매직 리터럴(상수로 선언하지 않은 리터럴)은 불필요한 질문을 유발한다.
- 더 나은 해결책은 `의미 있는 이름을 나타내는 상수를 도입`하는 것이다.

```java
RLConnection connection = new URL("http://bit.ly/15sYPA7").openConnection();
InputStream inputStream = connection.getInputStream();
search = new Search(inputStream, "smelt", "http://bit.ly/15sYPA7");
```

- Search 클래스를 생성하는 두 번쨰 호출은 제목 인수로 URL을 포함한다.

```java
public class SearchTest {
  private static final String A_TITLE = "1";

  @Test
  public void testSearch() throws IOException {
    // ...
    Search search = new Search(stream, "practical joke", A_TITLE);
    // ...
    assertThat(search.getMatches(), containsMatches(new Match[] { 
      new Match(A_TITLE, "practical joke", 
                "or a vast practical joke, though t") }));
    // ...
    search = new Search(inputStream, "smelt", A_TITLE);
  }
}
```

- 상수 이름은 ANY_TITLE이나 ARBITRARY_TITLE로 지어도 된다.

## 테스트 냄새: 부푼 생성

- Search 객체 생성자에 InputStream 객체를 넘거야 한다.

```java
String pageContent = "There are certain queer times and occasions "
// ...
byte[] bytes = pageContent.getBytes();
ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
```

- 이를 주어진 적절한 텍스트에 대한 InputStream 객체를 생성하는 도우미 메서드를 만드는 것이 좋다.
- 정신 사납게 하는 세부 사항은 숨기는 것이 좋다.

```java
public void testSearch() throws IOException {
      InputStream stream = 
        streamOn("There are certain queer times and occasions "
        // ...
        + "his own.");
      // 검색
      Search search = new Search(stream, "practical joke", A_TITLE);
      // ...
}

private InputStream streamOn(String pageContent) {
  return new ByteArrayInputStream(pageContent.getBytes());
}
```

## 테스트 냄새: 다수의 단언

- 단일 테스트마다 `단언은 한 개`인 것이 좋다.
- 때로 단일 테스트에 여러 사후 조건에 대한 단언이 필요한 경우도 있지만 그보다 자주 있는 것은 테스트 케이스 2개 이상을 포함하고 있다는 증거다.
- iloveyouboss_test-6/test/util/SearchTest.java
```java
@Test
public void returnsMatchesShowingContextWhenSearchStringInContent() 
      throws IOException {
  // ...
}

@Test
public void noMatchesReturnedWhenSearchStringNotInContent() 
      throws MalformedURLException, IOException {
  // ...
  inputStream.close();
}
```

- 그냥 반으로 쪼갰다면 두 번째 테스트에서 stream.close()가 호출되지 않는다는 것을 알 수 있다.
- 두 번째는 stream이 아니라 inputStream으로 바꿔야 한다.
  - 이는 변경 전에는 동일한 stream 참조에 두 번 close()를 호출했다는 것이다.
- 불필요한 주석은 제거해도 테스트 이름으로 내용을 한 눈에 알아볼 수 있다.


---
[Home](../README.md)
